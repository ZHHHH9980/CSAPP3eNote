# 第二章

知识点总结

https://www.cnblogs.com/lxm20145215----/p/5927612.html



## 理解😊

>  信息=位+上下文

<br>

位：

- 计算机以二进制数字的形式进行信息的存储和处理，即0/1，就称为位。

:chestnut: :`10` 即2个位。



上下文：

- 上下文规定了**解释的规则**,单独的`1`,`0`两个位并不能表示任何信息。但是我们把它们组合到一起，再加上上下文的解释，就产生了意义。



:chestnut:还是以`10`为例（就用两个位来表示十进制数）

- 无符号编码解释为 10进制的 `2`
- 有符号编码解释为 10进制的 `-2`



书上有很多例子，这里举一个最简单的

```c
#include <stdio.h>

int main(void) {
    int i = 64;

    printf("%d\n", i); //=> 64
    printf("%c\n", i); //=> '@'
    printf("%f\n", (float) i); //=> 64.000000
}
```

64的二进制表示(int 32位)

64_10 = 0000\:0000\:0000\:0000\:0000\:0000\:0100\:0000_2

位都是相同的，**上下文（解释规则）不同，得到的信息也不同**

<br>

## 实践😋

> 如何避免由计算机表示数字的方式引起的奇怪的数字



引起奇怪数字的原因

1.  隐式类型转换
2.  溢出



### 隐式类型转换

> 书上P58 sum_elements



```c
float sum_elements(float a[], unsigned length) {
	int i;
	float result = 0;

	for (i = 0; i <= length-1; i++)
		result += a[i];
	return result;
}

int main(void) {
	float a[3] = {1.0, 2.0, 3.0};
	unsigned length = 0;

	float result;
	result = sum_elements(a,length);
	printf("%f", result);
}
```

length是`unsigned`类型，跟常数1（默认为int 整型）做符号运算会被转换成`unsigned`。

当我们传入length = 0，理想情况下不会进入循环，直接返回0，而实际运行程序会返回内存引用错误。



我们用GDB设置断点进行调试

```c
Breakpoint 1, sum_elements (a=0x7fffffffdd8c, 
    length=0) at P58sum_elements.c:7
7		for (i = 0; i <= length-1; i++)

(gdb) p /t length-1
$1 = 11111111111111111111111111111111
```

运算：0 - 1 = -1 

有符号数的位表示`11111111...1111`即为-1。

但是此时length是无符号数，`11111...1111`会被**解释**为Umax即最大的无符号数，因此会出现数组访问越界的情况。



> 避免出现此类情况的方法之一就是绝不使用无符号数。





### 溢出

> 还有一个出现奇怪数字原因是**溢出**。

再以刚才的`unsigned length`在等于0的时候减去1会得到Umax。

Umax的位组合`11111111111111111111111111111111`即`4,294,967,295`

从数学角度`4,294,967,295+1`应该得到`4,294,967,296`

```c
int main (void) {
    unsigned length = 4,294,967,295;
    printf ("%d", length + 1); //=> 0
}
```

观察一下位组合的变化

`11111111111111111111111111111111` + 1

`1 | 00000000000000000000000000000000`

C语言中，`unsigned`类型用32位表示，此时出现了33位，发生了**溢出**,计算机会把最高位截断，因此得到最后的结果

`00000000000000000000000000000000` => 0